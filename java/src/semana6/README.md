# üß† Programaci√≥n Orientada a Objetos (POO) en Java - Parte 1: Fundamentos B√°sicos

---

## üîé ¬øQu√© es la Programaci√≥n Orientada a Objetos?

La Programaci√≥n Orientada a Objetos (POO) es una forma de programar en la que pensamos el c√≥digo como si estuvi√©ramos construyendo cosas del mundo real: objetos con **caracter√≠sticas** (estado) y **acciones** (comportamientos).

### üç™ Analog√≠a: Las galletas

- Una **clase** es el _molde_ de una galleta: define forma, sabor, color.
- Un **objeto** es la _galleta real_: tiene valores espec√≠ficos.
- Los **atributos** son las propiedades: sabor, color, tama√±o.
- Los **m√©todos** son las acciones: hornear, decorar, comer.

---

## üöó Ejemplo 1: Clase `Vehiculo` (archivo simple sin `package`)

Creamos una clase `Vehiculo` con atributos y un m√©todo, y luego una clase `Auto` que usa esa clase.

```java
// Vehiculo.java

// Declaramos la clase Vehiculo
public class Vehiculo {
    // Atributo que indica el tipo de veh√≠culo (Auto, Camion, Bicicleta)
    String tipo;

    // Atributo que representa la cantidad de ruedas del veh√≠culo
    int ruedas;

    // Atributo que indica el color del veh√≠culo
    String color;

    // M√©todo com√∫n que simula el movimiento del veh√≠culo
    public void avanzar() {
        // Imprime un mensaje cuando el veh√≠culo avanza
        System.out.println("El veh√≠culo est√° avanzando.");
    }
}

// Clase Auto con el m√©todo main para ejecutar el programa
class Auto {
    public static void main(String[] args) {
        // Creamos un objeto de tipo Vehiculo utilizando la palabra clave 'new'
        Vehiculo miAuto = new Vehiculo();

        // Asignamos valores a los atributos del objeto
        miAuto.tipo = "Auto";       // El tipo de veh√≠culo es "Auto"
        miAuto.ruedas = 4;          // Tiene 4 ruedas
        miAuto.color = "Rojo";     // El color es rojo

        // Mostramos en consola los valores asignados
        System.out.println("Tipo: " + miAuto.tipo);
        System.out.println("Ruedas: " + miAuto.ruedas);
        System.out.println("Color: " + miAuto.color);

        // Llamamos al m√©todo 'avanzar' del objeto
        miAuto.avanzar(); // Esto imprimir√°: El veh√≠culo est√° avanzando.
    }
}
```

> üí° Este ejemplo ayuda a comprender c√≥mo crear y usar una clase, atributos, m√©todos e instancias.

---

## üìÇ Ejemplo 2: Clase `Perro` usando `package` y modificadores de acceso

Ahora comenzamos a trabajar con **packages**, una forma profesional de organizar el c√≥digo. Tambi√©n aplicamos **encapsulamiento** con atributos `private` y m√©todos `public` (semana 5).

### üìÅ Estructura de carpetas sugerida

```
src/
‚îú‚îÄ‚îÄ semana6/
‚îÇ   ‚îú‚îÄ‚îÄ poo/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Perro.java
‚îÇ   ‚îî‚îÄ‚îÄ poo_main/
‚îÇ       ‚îî‚îÄ‚îÄ Mascota.java
```

---

### üê∂ `Perro.java` (ubicado en `semana6.poo`)

```java
// Declaramos el paquete donde se encuentra esta clase
package semana6.poo;

// Declaramos la clase Perro y la hacemos p√∫blica para que otras clases puedan usarla
public class Perro {

    // Atributo privado: solo accesible desde esta clase
    private String nombre;

    // Otro atributo privado: la raza del perro
    private String raza;

    // Atributo privado: edad del perro
    private int edad;

    // Setter para asignar un nombre al perro desde otra clase
    public void setNombre(String nombre) {
        this.nombre = nombre; // usamos "this" para referirnos al atributo de la clase
    }

    // Setter para asignar la raza
    public void setRaza(String raza) {
        this.raza = raza;
    }

    // Setter para asignar la edad
    public void setEdad(int edad) {
        this.edad = edad;
    }

    // M√©todo para que el perro ladre
    public void ladrar() {
        System.out.println("\u00a1Guau! \u00a1Guau!");
    }

    // M√©todo para imprimir toda la informaci√≥n del perro
    public void imprimirInformacion() {
        System.out.println("Nombre: " + nombre);
        System.out.println("Raza: " + raza);
        System.out.println("Edad: " + edad + " a√±os");
    }
}
```

---

### üêï `Mascota.java` (ubicado en `semana6.poo_main`)

```java
// Declaramos el paquete de esta clase principal
package semana6.poo_main;

// Importamos la clase Perro desde el paquete semana6.poo
import semana6.poo.Perro;

// Clase principal con el m√©todo main
public class Mascota {
    public static void main(String[] args) {
        // Creamos un nuevo objeto de tipo Perro porque este ser√° quien se comunique con nuestra Clase Perro que est√° en el package poo
        Perro miPerro = new Perro();

        // Establecemos los valores del objeto utilizando los m√©todos set (encapsulamiento)
        miPerro.setNombre("Rocky");       // Asignamos el nombre "Rocky"
        miPerro.setRaza("Labrador");      // Asignamos la raza "Labrador"
        miPerro.setEdad(4);                // Asignamos la edad 4

        // Hacemos que el perro realice una acci√≥n
        miPerro.ladrar(); // El perro ladra

        // Mostramos la informaci√≥n completa
        miPerro.imprimirInformacion();
    }
}
```

---

## üßë‚Äçüè´ Ejemplo adicional: Clase `Persona` generando autom√°ticamente m√©todos con IntelliJ IDEA

En IntelliJ IDEA, podemos usar atajos para generar autom√°ticamente c√≥digo repetitivo como constructores, getters, setters y `toString()`.

### üìÑ Clase `Persona`

```java
package semana6.poo;

public class Persona {
    private String nombre;
    private int edad;
    private String profesion;

    // Paso 1: Hacemos clic derecho dentro de la clase > Generate...
    // Paso 2: Seleccionamos "Constructor" y marcamos los campos deseados para inicializarlos

    public Persona(String nombre, int edad, String profesion) {
        this.nombre = nombre;
        this.edad = edad;
        this.profesion = profesion;
    }

    // Paso 3: Repetimos Generate... > Getter and Setter > Seleccionamos todos los campos

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public int getEdad() {
        return edad;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }

    public String getProfesion() {
        return profesion;
    }

    public void setProfesion(String profesion) {
        this.profesion = profesion;
    }

    // Paso 4: Generate... > toString() para representar el objeto como texto
    @Override
    public String toString() {
        return "Persona{" +
               "nombre='" + nombre + '\'' +
               ", edad=" + edad +
               ", profesion='" + profesion + '\'' +
               '}';
    }
}
```

### üß™ Uso en clase principal:

```java
Persona p = new Persona("Ana", 30, "Ingeniera");
System.out.println(p); // Usamos toString()
```

### üí¨ ¬øPara qu√© sirve cada uno?

| M√©todo      | Uso                                                                  |
| ----------- | -------------------------------------------------------------------- |
| Constructor | Inicializa los atributos cuando se crea un nuevo objeto              |
| Getter      | Permite **leer** el valor de un atributo privado                     |
| Setter      | Permite **modificar** el valor de un atributo privado                |
| toString()  | Devuelve una representaci√≥n en texto del objeto (√∫til para imprimir) |

---

## ‚ÑπÔ∏è Informaci√≥n adicional: Constructor vac√≠o (por defecto)

Un **constructor vac√≠o** permite crear un objeto sin pasarle datos al inicio. Es √∫til cuando:

1. Quieres **crear el objeto primero y asignar valores despu√©s**:

```java
Persona p = new Persona();
p.setNombre("Laura");
p.setEdad(28);
```

2. Lo requieren herramientas como **Spring**, **Jackson** o **Hibernate**, que necesitan crear objetos por reflexi√≥n.

3. Buscas **flexibilidad** al crear objetos sin tener toda la informaci√≥n en el momento.

### üß™ Ejemplo con constructor vac√≠o:

```java
public class Persona {
    private String nombre;
    private int edad;

    // Constructor vac√≠o
    public Persona() {
        // Se puede dejar vac√≠o o establecer valores por defecto
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public void setEdad(int edad) {
        this.edad = edad;
    }
}
```

Y su uso:

```java
Persona p = new Persona();
p.setNombre("Diego");
p.setEdad(32);
```

> üí° Recomendaci√≥n: si defines constructores con par√°metros, agrega tambi√©n el constructor vac√≠o cuando sea necesario para compatibilidad o flexibilidad.

---

## üß† Glosario t√©cnico

| T√©rmino             | Descripci√≥n                                                                 |
| ------------------- | --------------------------------------------------------------------------- |
| `class`             | Define una nueva clase (molde para objetos).                                |
| `object`            | Una instancia real de una clase.                                            |
| `new`               | Crea un nuevo objeto en memoria.                                            |
| `package`           | Agrupa clases relacionadas.                                                 |
| `import`            | Permite usar una clase ubicada en otro paquete.                             |
| `private`           | Restringe el acceso a un atributo o m√©todo solo dentro de su clase.         |
| `public`            | Permite el acceso desde cualquier parte del programa.                       |
| `this`              | Palabra clave que refiere al atributo de la instancia actual.               |
| `void`              | Indica que el m√©todo no devuelve ning√∫n valor.                              |
| `constructor`       | M√©todo especial que se llama al crear un objeto y sirve para inicializarlo. |
| `getter`            | M√©todo p√∫blico que devuelve el valor de un atributo privado.                |
| `setter`            | M√©todo p√∫blico que permite modificar un atributo privado.                   |
| `toString()`        | Representa el objeto como texto. Muy √∫til para debug o impresi√≥n.           |
| `constructor vac√≠o` | Constructor sin par√°metros, √∫til para inicializaci√≥n flexible o frameworks. |

---

# üß† Programaci√≥n Orientada a Objetos (POO) en Java - Parte 2: Herencia, Abstracci√≥n y Polimorfismo

---

## üìö Principios esenciales de la Programaci√≥n Orientada a Objetos

Antes de avanzar con los pilares avanzados, vamos a reforzar los principios fundamentales de la POO, especialmente el **encapsulamiento**, los **constructores**, los **getters y setters**, y el m√©todo especial `toString()`.

---

## üíä Encapsulamiento en Java

El encapsulamiento permite **proteger los datos internos de un objeto** y controlar c√≥mo se accede a ellos. En Java se logra usando:

- Atributos `private` (ocultos)
- M√©todos `get` y `set` (p√∫blicos y controlados)

---

### üìÑ Clase `Alumno` con explicaci√≥n l√≠nea por l√≠nea

```java
// Definimos una clase llamada Alumno
public class Alumno {

    // Atributos privados: no se pueden acceder directamente desde fuera de la clase
    private String nombre;
    private int edad;

    // Constructor: se llama autom√°ticamente al crear un nuevo objeto
    public Alumno(String nombre, int edad) {
        // 'this' se refiere al atributo de la clase
        this.nombre = nombre; // Asignamos el par√°metro al atributo 'nombre'
        this.edad = edad;     // Asignamos el par√°metro al atributo 'edad'
    }

    // Getter para el nombre: permite leer el valor de forma controlada
    public String getNombre() {
        return nombre;
    }

    // Setter para el nombre: permite cambiar el valor si lo necesitamos
    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    // Getter para la edad
    public int getEdad() {
        return edad;
    }

    // Setter para la edad
    public void setEdad(int edad) {
        // Podemos agregar validaciones aqu√≠ si queremos controlar qu√© valores se permiten
        if (edad >= 0) {
            this.edad = edad;
        }
    }

    // M√©todo especial que representa al objeto como texto
    @Override
    public String toString() {
        // Devuelve una cadena con los valores del objeto
        return "Alumno{" +
                "nombre='" + nombre + '\'' +
                ", edad=" + edad +
                '}';
    }
}
```

---

### üß™ Clase principal para probar `Alumno`

```java
public class Main {
    public static void main(String[] args) {
        // Creamos un nuevo alumno con nombre y edad
        Alumno alumno1 = new Alumno("Luc√≠a", 20);

        // Mostramos los valores usando el m√©todo toString()
        System.out.println(alumno1); // Salida: Alumno{nombre='Luc√≠a', edad=20}

        // Cambiamos la edad usando el setter
        alumno1.setEdad(21);

        // Mostramos nuevamente los valores usando getters
        System.out.println("Nombre: " + alumno1.getNombre()); // Luc√≠a
        System.out.println("Edad: " + alumno1.getEdad());     // 21
    }
}
```

---

## ‚úÖ ¬øCu√°ndo usamos getters y setters?

| Situaci√≥n                         | ¬øPor qu√© usar `get` y `set`?                               |
| --------------------------------- | ---------------------------------------------------------- |
| Encapsular informaci√≥n sensible   | Evita acceso directo y protege los datos.                  |
| Agregar validaciones              | Por ejemplo: no permitir edad negativa.                    |
| Permitir solo lectura o escritura | Puedes tener solo `get` o solo `set` seg√∫n el caso.        |
| Facilitar mantenimiento           | Si cambias la l√≥gica interna, no afecta el c√≥digo externo. |

---

## üß† Constructor: ¬øQu√© es y para qu√© sirve?

- Se llama autom√°ticamente cuando usamos `new` para crear un objeto.
- Permite inicializar los valores de los atributos desde el principio.
- Puede haber m√°s de uno (constructores sobrecargados).

### üìå Cu√°ndo usar constructores

- Cuando quieres asegurar que un objeto **siempre** tenga valores v√°lidos desde el inicio.
- Cuando el objeto necesita preparaci√≥n especial (por ejemplo: calcular un ID, abrir una conexi√≥n, etc).

---

## üß† M√©todo `toString()`: ¬øPara qu√© sirve?

- Permite representar el objeto como texto.
- Se ejecuta autom√°ticamente si usamos `System.out.println(objeto)`.

### üìå Cu√°ndo sobrescribir `toString()`

- Siempre que quieras ver los datos internos del objeto de forma legible.
- √ötil para debug, logs, o visualizaci√≥n en interfaces.

| Instrucci√≥n                    | Equivalente interno                       | Resultado                            |
| ------------------------------ | ----------------------------------------- | ------------------------------------ |
| `System.out.println(alumno1);` | `System.out.println(alumno1.toString());` | Llama autom√°ticamente a `toString()` |
| `toString()` no sobrescrito    | `Alumno@123abc`                           | Poco √∫til                            |
| `toString()` sobrescrito       | `Alumno{nombre='Luc√≠a', edad=20}`         | Legible y √∫til para debugging        |

---

Hasta aqu√≠ hemos trabajado con clases, atributos, m√©todos, constructores, encapsulamiento y c√≥mo generar `getters`, `setters` y `toString()` autom√°ticamente. Ahora vamos a dar el siguiente gran paso: aplicar los **pilares avanzados de la POO**.

## üß± Pilares avanzados de la POO

A continuaci√≥n damos el siguiente gran paso: aplicar los **pilares avanzados de la Programaci√≥n Orientada a Objetos**.

Los pilares que veremos ahora son:

1. üß¨ **Herencia**
2. üé≠ **Polimorfismo**
3. üß† **Abstracci√≥n**

---

# üß¨ HERENCIA: Reutilizando c√≥digo entre clases

La herencia es un principio clave que permite crear una nueva clase a partir de una existente. La clase original se llama **superclase** o **clase padre**, y la nueva se llama **subclase** o **clase hija**.

La subclase hereda los atributos y m√©todos de la superclase, pero puede agregar o sobrescribir comportamientos propios. Nos ayuda a **reutilizar c√≥digo** y a representar jerarqu√≠as del mundo real.

### üèóÔ∏è Ejemplo visual: Veh√≠culo, Taxi y Autob√∫s

**Superclase:** `Vehiculo`
**Subclases:** `Taxi` y `Autobus`

```java
// Superclase Vehiculo
public class Vehiculo {
    protected String matricula;
    protected String modelo;
    protected int potenciaCV;

    public String getMatricula() {
        return matricula;
    }

    public String getModelo() {
        return modelo;
    }

    public int getPotenciaCV() {
        return potenciaCV;
    }
}
```

```java
// Subclase Taxi
public class Taxi extends Vehiculo {
    private String numeroLicencia;

    public void setNumeroLicencia(String numeroLicencia) {
        this.numeroLicencia = numeroLicencia;
    }

    public String getNumeroLicencia() {
        return numeroLicencia;
    }
}
```

```java
// Subclase Autobus
public class Autobus extends Vehiculo {
    private int numeroPlazas;

    public void setNumeroPlazas(int numeroPlazas) {
        this.numeroPlazas = numeroPlazas;
    }

    public int getNumeroPlazas() {
        return numeroPlazas;
    }
}
```

---

## üß† Sintaxis y buenas pr√°cticas en herencia

### üîë Palabra clave `extends`

En Java, `extends` se utiliza para establecer la relaci√≥n de herencia entre una subclase (clase hija) y una superclase (clase padre).

```java
class Subclase extends Superclase {
    // Cuerpo de la subclase
}
```

### üß± Superclase

La superclase es la clase principal de la cual se deriva otra clase. Tambi√©n se conoce como clase base o **clase padre**. Contiene **atributos y m√©todos comunes** que pueden ser heredados por las subclases.

### üìÑ Clase base: `Animal`

```java
// Superclase o clase padre/base
public class Animal {
    protected String nombre; // Usamos 'protected' para que las subclases puedan acceder

    // M√©todo visible desde fuera de la clase
    public void dormir() {
        System.out.println(nombre + " est√° durmiendo...");
    }

    // M√©todo sin modificador (package-private)
    void comer() {
        System.out.println("El animal come");
    }
}
```

### üß© Subclase

La subclase es la clase que se deriva de otra clase (superclase). Tambi√©n se conoce como clase derivada o **clase hija**. Puede tener sus propios atributos y m√©todos.

### üê∂ Clase derivada: `Perro`

```java
// Subclase o clase derivada
public class Perro extends Animal {
    // M√©todo propio del Perro
    public void ladrar() {
        System.out.println(nombre + " dice ¬°Guau!");
    }

    // Sobrescritura opcional (si existiera en la superclase)
    void comer() {
        System.out.println("El perro come croquetas");
    }
}
```

---

### üß™ Uso en `Main`

```java
public class Main {
    public static void main(String[] args) {
        Perro p = new Perro();
        p.nombre = "Rocky";     // Acceso permitido por ser 'protected'
        p.dormir();              // Heredado de Animal
        p.ladrar();              // Propio de Perro
        p.comer();               // M√©todo sobrescrito (override)
    }
}
```

> üß† Usamos `protected` para que el atributo `nombre` pueda ser heredado.

---

## üß† TIPS √∫tiles para herencia

- ‚úÖ Usa `protected` para atributos/m√©todos que quieras compartir entre superclase y subclases.
- ‚ùå No uses `private` si necesitas acceder desde las subclases.
- ‚úÖ M√©todos `public` pueden ser heredados y llamados desde cualquier parte.
- ‚ö†Ô∏è M√©todos `void` se usan cuando **no se necesita retornar ning√∫n valor**, solo ejecutar una acci√≥n.
- ‚úÖ M√©todos con `return` deben declarar su tipo (por ejemplo `int`, `String`, etc).

> üí° Reglas pr√°cticas:
>
> - Usa `void` si solo quieres que el m√©todo haga algo (ej: imprimir, guardar, mover).
> - Usa `return` cuando el m√©todo deba devolver un resultado.
> - Usa `protected` cuando un atributo o m√©todo deba ser heredado pero no expuesto p√∫blicamente.

### üß™ Ejercicio pr√°ctico de herencia aplicado al contexto acad√©mico

Este ejercicio simula un sistema acad√©mico con estudiantes de distintos niveles y tipos de curso. Usaremos herencia para representar las variaciones.

> üì¶ Ubicaci√≥n sugerida: Puedes ubicar esto en el paquete `semana6.RefugioAnimal` para mantener tu c√≥digo organizado.

---

#### üß± Clase base: Estudiante

```java
public class Estudiante {
    protected String nombre;
    protected int edad;

    public Estudiante(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }

    public void estudiar() {
        System.out.println("El estudiante est√° estudiando.");
    }

    public String getNombre() {
        return nombre;
    }
}
```

#### üß© Subclases: EstudianteSecundaria y EstudianteUniversitario

```java
public class EstudianteSecundaria extends Estudiante {
    private String especialidad;

    public EstudianteSecundaria(String nombre, int edad, String especialidad) {
        super(nombre, edad);
        this.especialidad = especialidad;
    }

    @Override
    public void estudiar() {
        System.out.println(nombre + " estudia materias generales en secundaria.");
    }
}
```

```java
public class EstudianteUniversitario extends Estudiante {
    private String carrera;
    private int creditosAprobados;

    public EstudianteUniversitario(String nombre, int edad, String carrera, int creditosAprobados) {
        super(nombre, edad);
        this.carrera = carrera;
        this.creditosAprobados = creditosAprobados;
    }

    @Override
    public void estudiar() {
        System.out.println(nombre + " estudia la carrera de " + carrera + ".");
    }
}
```

Si no deseas agregar mas clases de ejemplo baja diracto al Main

---

#### üìò Clase base: Curso

```java
public class Curso {
    protected String nombreCurso;
    protected String profesor;

    public Curso(String nombreCurso, String profesor) {
        this.nombreCurso = nombreCurso;
        this.profesor = profesor;
    }

    public void mostrarInfo() {
        System.out.println("Curso: " + nombreCurso + " | Profesor: " + profesor);
    }
}
```

#### üß© Subclases: CursoBachillerato y CursoPosgrado

```java
public class CursoBachillerato extends Curso {
    private String especialidad;

    public CursoBachillerato(String nombreCurso, String profesor, String especialidad) {
        super(nombreCurso, profesor);
        this.especialidad = especialidad;
    }

    @Override
    public void mostrarInfo() {
        System.out.println("[Bachillerato] " + nombreCurso + " | Prof: " + profesor + " | Especialidad: " + especialidad);
    }
}
```

```java
public class CursoPosgrado extends Curso {
    private int nivel;

    public CursoPosgrado(String nombreCurso, String profesor, int nivel) {
        super(nombreCurso, profesor);
        this.nivel = nivel;
    }

    @Override
    public void mostrarInfo() {
        System.out.println("[Posgrado] " + nombreCurso + " | Prof: " + profesor + " | Nivel: " + nivel);
    }
}
```

---

### üß™ Clase `Main` con pruebas del sistema

```java
public class Main {
    public static void main(String[] args) {

        // Estudiantes
        EstudianteSecundaria est1 = new EstudianteSecundaria("Ana", 16, "Cient√≠fica");
        EstudianteUniversitario est2 = new EstudianteUniversitario("Luis", 21, "Ingenier√≠a", 150);

        est1.estudiar();
        est2.estudiar();

        // Cursos
        CursoBachillerato curso1 = new CursoBachillerato("Biolog√≠a", "Dra. Mart√≠nez", "Ciencias Naturales");
        CursoPosgrado curso2 = new CursoPosgrado("Gesti√≥n de Proyectos", "Dr. P√©rez", 2);

        curso1.mostrarInfo();
        curso2.mostrarInfo();
    }
}
```

‚úÖ Este ejercicio refuerza los pilares de herencia, encapsulamiento y sobrescritura (`@Override`), adem√°s de ilustrar c√≥mo organizar el c√≥digo en clases reutilizables para escenarios reales como un sistema acad√©mico.

---

### üß† ¬øQu√© hace `@Override`?

La anotaci√≥n `@Override` se utiliza cuando **queremos sobrescribir un m√©todo que viene de la clase padre**.

- Es una forma clara de indicar que el m√©todo redefine un comportamiento heredado.
- Si el m√©todo padre no existe o est√° mal escrito, el compilador mostrar√° un error.

#### Ejemplo:

```java
public class Animal {
    public void hablar() {
        System.out.println("El animal hace un sonido");
    }
}

public class Gato extends Animal {
    @Override
    public void hablar() {
        System.out.println("El gato dice miau");
    }
}
```

üí° **Tips pr√°cticos:**

- Solo puedes sobrescribir m√©todos que no sean `private` ni `static`.
- El m√©todo sobrescrito debe tener **el mismo nombre, par√°metros y tipo de retorno**.
- Siempre usa `@Override` para ayudar al compilador a detectar errores.

---


# üé≠ POLIMORFISMO: Una interfaz, muchas formas

El polimorfismo permite que una misma interfaz (m√©todo o clase) se comporte de distintas maneras seg√∫n el tipo de objeto que la implemente. En Java, esto se logra de dos formas:

1. **Sobrecarga de m√©todos** (`Overloading`) ‚Üí mismos nombres, diferentes par√°metros.
2. **Sobrescritura de m√©todos** (`Overriding`) ‚Üí redefinir un m√©todo heredado.

### üß† ¬øPara qu√© sirve el polimorfismo?

* Reduce duplicaci√≥n de c√≥digo.
* Hace el sistema extensible.
* Permite tratar objetos distintos de forma uniforme.


### ‚úçÔ∏è Sobrescritura (override)

```java
class Animal {
    public void hablar() {
        System.out.println("El animal hace un sonido");
    }
}

class Gato extends Animal {
    @Override
    public void hablar() {
        System.out.println("El gato dice miau");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Animal a = new Gato(); // Polimorfismo
        a.hablar(); // Llama a Gato.hablar()
    }
}
```

### ‚ûï Sobrecarga (overload)

```java
public class Calculadora {
    public int sumar(int a, int b) {
        return a + b;
    }

    public double sumar(double a, double b) {
        return a + b;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Calculadora calc = new Calculadora();
        System.out.println(calc.sumar(2, 3));       // 5
        System.out.println(calc.sumar(2.5, 3.1));   // 5.6
    }
}
```

---



# üß† ABSTRACCI√ìN: Esconder lo innecesario, mostrar lo importante

La **abstracci√≥n** consiste en **representar solo los aspectos esenciales** de un objeto, ignorando los detalles irrelevantes para el prop√≥sito actual del programa. En Java, esto se logra principalmente con clases y m√©todos abstractos.

Una **clase abstracta** no se puede instanciar directamente y act√∫a como una **plantilla com√∫n** para otras clases que s√≠ ser√°n concretas. Puede contener:

* M√©todos abstractos (sin implementaci√≥n, obligan a implementarlos en subclases).
* M√©todos concretos (con implementaci√≥n).

---

### üìä Ejemplo visual: Veh√≠culo, Auto, Cami√≥n, Bicicleta

```java
// Clase abstracta Vehiculo
public abstract class Vehiculo {
    // M√©todo concreto (tiene implementaci√≥n com√∫n)
    public void arrancar() {
        System.out.println("El veh√≠culo ha arrancado.");
    }

    // M√©todo abstracto (obligatorio en las subclases)
    public abstract void conducir();
}
```

---

### üöó Subclases concretas

```java
// Subclase Auto
public class Auto extends Vehiculo {
    @Override
    public void conducir() {
        System.out.println("El auto est√° en movimiento.");
    }
}
```

```java
// Subclase Camion
public class Camion extends Vehiculo {
    @Override
    public void conducir() {
        System.out.println("El cami√≥n est√° en movimiento.");
    }
}
```

```java
// Subclase Bicicleta
public class Bicicleta extends Vehiculo {
    @Override
    public void conducir() {
        System.out.println("La bicicleta est√° en movimiento.");
    }
}
```

---

### üß™ Uso en clase `Main`

```java
public class Main {
    public static void main(String[] args) {
        Vehiculo auto = new Auto();
        Vehiculo camion = new Camion();
        Vehiculo bici = new Bicicleta();

        auto.arrancar();
        auto.conducir();

        camion.arrancar();
        camion.conducir();

        bici.arrancar();
        bici.conducir();
    }
}
```
Otro Ejemplo 

### üõë Clase abstracta: `Figura`

```java
public abstract class Figura {
    public abstract double calcularArea();

    public void mostrarTipo() {
        System.out.println("Soy una figura geom√©trica.");
    }
}
```

### ‚≠ï Subclase concreta: `Circulo`

```java
public class Circulo extends Figura {
    private double radio;

    public Circulo(double radio) {
        this.radio = radio;
    }

    @Override
    public double calcularArea() {
        return Math.PI * radio * radio;
    }
}
```

### üß™ Uso en `Main`

```java
public class Main {
    public static void main(String[] args) {
        Figura f = new Circulo(5);
        f.mostrarTipo();
        System.out.println("√Årea: " + f.calcularArea());
    }
}
```

> üìå No puedes instanciar `Figura`, solo sus subclases. El m√©todo `calcularArea()` debe ser implementado.


---

## üß† ¬øPor qu√© usar abstracci√≥n?

* üîê Obliga a las subclases a implementar m√©todos importantes.
* üì¶ Centraliza l√≥gica com√∫n en un solo lugar (la clase abstracta).
* üß± Mejora la arquitectura del sistema (principio de dise√±o SOLID: Liskov y Segregaci√≥n).

---

### üí° Tips importantes:

* Solo puedes usar `abstract` en clases y m√©todos.
* Si una clase tiene **al menos un m√©todo abstracto**, entonces **la clase tambi√©n debe ser abstracta**.
* No puedes crear instancias de una clase abstracta (`new Vehiculo()` ‚ùå).
* Las subclases deben **obligatoriamente** implementar todos los m√©todos abstractos de la clase padre, a menos que tambi√©n sean abstractas.
* Puedes combinar m√©todos concretos y abstractos en la misma clase abstracta.




# üéØ Interfaces en Java: una extensi√≥n del principio de Abstracci√≥n

## üìö ¬øQu√© es una interfaz?

Una **interfaz** en Java es una colecci√≥n de m√©todos **abstractos por definici√≥n**. Define **qu√© se debe hacer**, pero no c√≥mo.

Se considera una forma pura de **abstracci√≥n** y permite a diferentes clases **compartir una misma forma de comportamiento** sin heredar implementaci√≥n.

---

## ü§î ¬øEs parte de la POO?

‚úÖ ¬°S√≠! Las interfaces **forman parte esencial de la programaci√≥n orientada a objetos** y est√°n directamente relacionadas con el principio de **abstracci√≥n**.

| Comparaci√≥n        | Clase abstracta       | Interface                          |
| ------------------ | --------------------- | ---------------------------------- |
| M√©todos sin cuerpo | ‚úÖ S√≠                  | ‚úÖ S√≠                               |
| M√©todos con cuerpo | ‚úÖ S√≠                  | ‚úÖ Desde Java 8 (`default`)         |
| Herencia m√∫ltiple  | ‚ùå No                  | ‚úÖ S√≠ (puedes implementar varias)   |
| Palabra clave      | `extends`             | `implements`                       |
| Uso com√∫n          | Compartir l√≥gica base | Definir contrato de comportamiento |

---

## üß± Ejemplo pr√°ctico de interfaces

### Paso 1: Definir las interfaces

```java
// Interfaz Conducible
public interface Conducible {
    void conducir();
}

// Interfaz Arrancable
public interface Arrancable {
    void arrancar();
}
```

---

### Paso 2: Clase abstracta que las implementa

```java
public abstract class Vehiculo implements Conducible, Arrancable {
    @Override
    public void arrancar() {
        System.out.println("El veh√≠culo ha arrancado.");
    }
}
```

---

### Paso 3: Subclases concretas

```java
public class Auto extends Vehiculo {
    @Override
    public void conducir() {
        System.out.println("El auto est√° en movimiento.");
    }
}

public class Camion extends Vehiculo {
    @Override
    public void conducir() {
        System.out.println("El cami√≥n est√° en movimiento.");
    }
}

public class Bicicleta extends Vehiculo {
    @Override
    public void conducir() {
        System.out.println("La bicicleta est√° en movimiento.");
    }
}
```

---

### üß™ Clase `Main`

```java
public class Main {
    public static void main(String[] args) {
        Vehiculo auto = new Auto();
        auto.arrancar();
        auto.conducir();
    }
}
```
---
## üí° Reglas, buenas pr√°cticas y tips sobre interfaces

‚úÖ **Cu√°ndo usar interfaces:**

* Cuando varias clases no relacionadas deben compartir un comportamiento com√∫n.
* Cuando quieres permitir herencia m√∫ltiple de comportamiento (Java no permite herencia m√∫ltiple con clases, pero s√≠ con interfaces).
* Cuando est√°s dise√±ando una API p√∫blica y quieres separar contrato de implementaci√≥n.

‚ö†Ô∏è **Tips clave:**

* No puedes tener atributos con l√≥gica en una interfaz (solo constantes `public static final`).
* A partir de Java 8 puedes usar `default` y `static` para incluir l√≥gica en una interfaz.
* Una clase puede implementar m√∫ltiples interfaces, pero solo extender una clase.
* Prefiere interfaces cuando el comportamiento puede variar seg√∫n la clase.



---

## üéØ Mini ejercicio din√°mico con Scanner e interfaces

```java
import java.util.Scanner;

interface Volable {
    void volar();
}

class Avion implements Volable {
    public void volar() {
        System.out.println("El avi√≥n est√° despegando a gran velocidad.");
    }
}

class Helicoptero implements Volable {
    public void volar() {
        System.out.println("El helic√≥ptero est√° flotando en el aire.");
    }
}

public class MainVolador {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("¬øQu√© deseas volar? (avion/helicoptero): ");
        String opcion = sc.nextLine();

        Volable maquina;

        if (opcion.equalsIgnoreCase("avion")) {
            maquina = new Avion();
        } else {
            maquina = new Helicoptero();
        }

        maquina.volar();
        sc.close();
    }
}
```

‚úÖ Con este ejercicio vemos polimorfismo aplicado a interfaces, selecci√≥n de comportamiento en tiempo de ejecuci√≥n y reutilizaci√≥n de c√≥digo. ¬°Ideal para entender c√≥mo usar interfaces en la vida real!

---


## üß† Glosario unificado: Herencia, Polimorfismo y Abstracci√≥n


| Concepto          | Significado                                                                  |
| ----------------- | ---------------------------------------------------------------------------- |
| `extends`         | Permite heredar de otra clase                                                |
| `super`           | Llama al constructor o m√©todos de la clase padre                             |
| `abstract class`  | Clase que no puede instanciarse directamente                                 |
| `abstract method` | M√©todo sin cuerpo que debe ser implementado en subclases                     |
| `@Override`       | Indica que se est√° sobrescribiendo un m√©todo heredado                        |
| `polimorfismo`    | Permite usar una clase base para representar m√∫ltiples formas                |
| `sobrecarga`      | Mismo m√©todo, diferentes par√°metros                                          |
| `sobrescritura`   | Mismo m√©todo, redefinido en una subclase                                     |
| Clase concreta    | Clase normal que puede ser instanciada y debe implementar m√©todos abstractos |
| Plantilla base    | Papel que cumple la clase abstracta al definir una interfaz com√∫n            |



### üìò Preguntas frecuentes (FAQ) por pilar de la POO

#### üß¨ Herencia

* **¬øPuedo heredar m√∫ltiples clases en Java?**
  ‚ùå No. Java no permite herencia m√∫ltiple con clases (s√≠ con interfaces).

* **¬øQu√© modificadores debo usar para que los atributos/m√©todos se hereden?**
  ‚úÖ Usa `protected` para que puedan ser accedidos desde subclases.
  ‚ùå `private` no puede ser heredado directamente.

* **¬øPuedo sobreescribir un m√©todo heredado?**
  ‚úÖ S√≠, si no es `private` ni `final`. Usa `@Override` para mayor claridad.

* **¬øPara qu√© sirve `super`?**
  Permite llamar al constructor o m√©todos de la clase padre.

---

#### üé≠ Polimorfismo

* **¬øQu√© es polimorfismo en una frase?**
  üëâ Es cuando una **misma referencia** puede tomar diferentes comportamientos seg√∫n la clase que instancia.

* **¬øCu√°l es la diferencia entre sobreescritura y sobrecarga?**
  üîÅ **Sobreescritura:** redefinir un m√©todo en la subclase (`@Override`).
  ‚ûï **Sobrecarga:** mismo nombre de m√©todo, pero con diferentes par√°metros.

* **¬øSiempre debo usar `@Override`?**
  ‚úÖ S√≠, es buena pr√°ctica. Ayuda al compilador a detectar errores si el m√©todo padre no existe.

* **¬øPuedo usar polimorfismo con clases abstractas?**
  ‚úÖ S√≠, es muy com√∫n. Se define una clase abstracta y se usa su referencia para instanciar subclases.

---

#### ‚ú® Abstracci√≥n

* **¬øPuedo tener m√©todos normales en una clase abstracta?**
  ‚úÖ S√≠. Puedes tener m√©todos con implementaci√≥n (concretos) junto a m√©todos abstractos.

* **¬øTodos los m√©todos abstractos deben ser `public`?**
  ‚ùå No obligatoriamente, pero:

  * ‚úÖ Se recomienda `public` para que las subclases puedan sobrescribirlo.
  * ‚ùå No pueden ser `private`, porque no ser√≠an accesibles desde subclases.
  * ‚ö†Ô∏è Se puede usar `protected` si solo deben sobrescribirse dentro del mismo paquete jer√°rquico.

* **¬øPuedo instanciar una clase abstracta?**
  ‚ùå No. Debes usar una subclase concreta.

* **¬øPara qu√© usar abstracci√≥n si puedo usar herencia?**
  üí° Porque la abstracci√≥n **obliga a implementar comportamientos claves** y mejora la arquitectura.



‚úÖ Esto cierra el recorrido por los **tres pilares avanzados de la POO**: Herencia, Polimorfismo y Abstracci√≥n.